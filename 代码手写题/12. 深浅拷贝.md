### 基本概念

深拷贝和浅拷贝都是针对对象而言的。深浅拷贝的出现也是具有实际意义的，因为在JavaScript中经常需要使用到复制对象的方法，如果不了解这些方法的原理，在复制对象的时候是很容易踩坑的。

### 浅拷贝

浅拷贝是创建一个新的对象，其拥有原对象属性值的精确复制。如果属性值为基本数据类型，就拷贝属性值；如果属性值为引用数据类型，则拷贝地址值。也就是说，如果其中一个对象更改了属性值，那么这些改变也会反应在新创建的对象中。

浅拷贝的实现思路很简单，遍历对象的属性然后赋给新对象。同时注意，**浅拷贝指拷贝对象自身的属性，不会涉及任何对象原型身上的属性。**

```javascript
function shallowCopy(obj) {
    //检查是否为引用数据类型
    if (typeof obj !== 'object') return
    //根据原对象的类型确定新对象是数组还是普通对象
    let newObj = obj instanceof Array ? [] : {}
    //遍历所有属性并且赋值给新对象
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = obj[key]
        }
    }
    return obj
}
```

### 深拷贝

深拷贝则是相对浅拷贝而言的，深拷贝会开辟一块全新的内存空间存放拷贝的对象，并且修改其中一个对象的属性不会对另一个对象产生任何影响。

深拷贝的实现方式在原生JavaScript中比较通用的有两种，一种是基于JSON来实现的

```javascript
let obj = {name: 'Jack'}
let copyObj = JSON.parse(JSON.stingify(obj))
```

经过JSON转换之后的对象和原对象之间已经没有任何联系了，各自占用完全不同的内存空间。不过这样的方式也有缺点，那就是如果遇到不支持JSON的数据类型我们就没辙了。

因此还有另一种比较麻烦但是更加通用的方法，那就是递归。我们每遍历一个对象属性就判断一下其是否为对象是则循环调用深拷贝函数，直到我们找到基本数据类型，此时才会将基本数据类型赋给新的拷贝对象。思路并不复杂，代码也很简单。

```javascript
function deepCopy(obj) {
    //检查是否为引用数据类型
    if (typeof obj !== 'object') return
    //根据原对象的类型确定新对象是数组还是普通对象
    let newObj = obj instanceof Array ? [] : {}
    //遍历所有属性并且赋值给新对象
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (typeof obj[key] === 'object') {
                deepCopy(obj[key])
            }else {
                newObj[key] = obj[key]
            }
        }
    }
    return obj
}
```

这里看文章发现这种深拷贝的实现还存在循环引用的问题没有解决，不过目前个人能力有限加上准备面试事件比较紧张，所以就先搁置一下，后续事件宽松了再补上吧。（逃）

