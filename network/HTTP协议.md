> 网络上的东西都是虚拟的（指计算机网络比较抽象），你不好把握住啊。

## HTTP协议

超文本传输协议`http`，基于`TCP/IP`协议进行数据传输。

### `GET`和`POST`的区别

`GET`语义上来说用于**查找获取**服务器资源，因为主要是获取资源而非操作资源，所以`GET`请求的报文主体为空，请求的资源信息包含在`URL`的参数中。浏览器一般会限制`URL`的长度但是`HTTP`协议本身并不会。`GET`请求的资源一般都会进行缓存。

`POST`请求则是对于服务器资源的**操作**，会修改服务器上存储的资源，所以它会携带报文主体信息，`POST`请求的信息一般不会进行缓存。

**`GET`安全，幂等且一般要缓存。`POST`不安全，不幂等，一般不缓存。**

> 安全：请求不会修改服务器上的资源。
>
> 幂等：多次执行相同操作，得到的结果都是相同的

### 常见的HTTP请求方法

- `GET`：向服务器获取数据。浏览器对`URL`长度一般有限制，所以一般不超过`4KB`。
- `POST`：将请求主体提交至服务器，通常会造成服务器资源的修改。
- `PUT`：上传文件，更新数据。和`POST`相比，是幂等的。
- `DELETE`：删除服务器上的对象。
- `HEAD`：获取报文头部，不会返回具体的响应内容。
- `OPTIONS`：询问支持的请求方法，跨域请求的`CORS`复杂模式就会发送`OPTIONS`请求。
- `CONNECT`：开启客户端与所请求资源间的一个双向沟通的通道，它可以用来创建隧道`tunnel`
- `TRACE`：显示服务器收到的请求，可以用于调试和检测`bug`。
- `PATCH`：对资源进行部分修改。

### 请求头

- `Accept`：告知服务器浏览器能够处理的内容类型。
- `Accept-Charset`：浏览器能够处理的字符集类型。
- `Accept-Encoding`：浏览器能够处理的内容编码类型，通常是某种压缩算法。
- `Accept-Language`：浏览器呢可以识别的自然语言。
- `Connection`：是否要建立持久的网络连接。
- `Cookie`：请求服务器时会自动将该域名下的`cookie`携带发送。
- `Host`：要将请求发送至的服务器的域名和端口号。
- `Referer`：发出请求页面的`URL`，用来防止`CSRF`攻击。
- `User-Agent`：浏览器的用户代理字符串。
- `If-Modified-Since`：协商缓存中的`Last-Modified`对应的字段，表示文件的最后修改时间。
- `If-None-Match`：协商缓存中的`Etag`值，作为每个资源的唯一标识。

### 响应头

- `Date`：响应报文创建的时间和日期。
- `server`：服务器的名称。
- `Connection`：链接类型，为`keep-alive`表示建立持久连接。
- `Cache-Control`：告诉浏览器需要采取的缓存策略，如果是强缓存还可以设置缓存过期时间，`max-age`。
- `Content-Type`：用来指示资源的MIME类型。
- `Content-Scurity-Policy`：用于告诉浏览器，哪些外部资源可以进行加载，防范`XSS`攻击。
- `Access-Control-Allow-Origin`：用于跨域中，告诉浏览器可以进行跨域资源共享的源。

### 状态码

#### 1XX 继续请求

- 100。处于请求处理的中间状态，客户端应该继续进行请求。
- 101。客户端请求切换协议。

#### 2XX 请求成功

- 200。最常见的状态码，表示请求成功。
- 201。成功在服务器创建了新的资源。
- 204。请求成功，但是服务器没有任何资源返回。
- 206。客户端进行了范围请求。

#### 3XX 重定向

- 301。资源移动到了新的地址，下次访问记得使用新的地址。
- 302。同样是资源移动了，不过此时给的是一个临时重定向，下次访问还是使用旧地址。
- 304。命中缓存的状态码，命中协商缓存的时候会返回。

#### 4XX 客户端错误

- 400。客户端的请求报文中有错误。
- 401。限制访问，可能是访问的资源需要进行身份验证。
- 403。资源禁止访问。
- 404。服务器找不到客户端要请求的资源。

#### 5XX 服务器错误

- 500。服务器错误，一个笼统的描述。
- 502。代理服务器或者网关从上游服务器接收的信息是无效的，无法返回给客户端。
- 503。服务器繁忙，展示无法处理客户端的请求。（学校抢课现状！）
- 504。请求超时。

### HTTP缓存

可以参考我在浏览器原理里面写的浏览器缓存一章。

### HTTP的进化历史

#### HTTP/1.1

`http/1.1`在`1.0`的基础之上进行了改进，主要有以下几点改进。

- 引入`TCP`长连接。避免每发送一次请求就经历一次`TCP`握手而导致的时间浪费。
- 引入还未成熟的管线技术。解决了请求的队头阻塞，但是没有解决响应的队头阻塞问题。
- 引入`Cookie`机制。解决由于`http`协议的无状态导致的问题。

虽然改进了很多还是问题还是不少：

- 无法解决响应的队头阻塞问题。
- 可以建立多个`TCP`链接，但是各个`TCP`链接启动慢而且相互之间会竞争带宽。

#### HTTP/2.0

针对`HTTP/1.1`存在的问题进行的修改。多路复用技术的引入解决了队头阻塞和带宽竞争的问题。

- 二进制分帧。报文转换为二进制发送，通过打上`ID`来识别。
- 单个`TCP`长连接。只建立一个`TCP`长链接，避免慢启动和带宽利用不充分的问题。
- 解决了响应的队头阻塞问题。可以实现无序传输，再也不用等前面的请求和响应了。
- 服务器推动。请求的`HTML`如果依赖了外部的其他资源，服务器直接一并推送，不用客户端再单独进行请求。

但是缺点依旧存在，那就是`TCP`连接里的队头阻塞问题还是没有办法解决。传输过程中，如果前一个`Stream`中的数据丢失了，后面的数据即使接收到了也无法读取。

#### HTTP/3.0

为了解决`HTTP/2.0`的问题，`3.0`版本直接抛弃了`TCP`协议，采用了基于`UDP`的`QUIC`实现。主要有以下几个特点。

- `QUIC`基于`UDP`，彻底解决了队头阻塞的问题。
- 更加快速的建立连接。通过给连接双方一个`ID`，只需一次`RTT`即可建立连接。
- 高效的连接迁移。从4G切换到WIFI，IP地址改变了，`TCP`连接需要从新进行`TCP`握手的过程才能建立连接。但是`QUIC`由于是基于`ID`连接双方的，所以这个时候可以直接“无缝”切换，不用再经历一遍建立连接的过程。（频繁切换网络用户的福音）



