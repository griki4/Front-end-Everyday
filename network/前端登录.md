## Cookie + Session

最为传统也是最简单的登录方式，目前使用依旧非常广泛。

`HTTP`是无状态的协议，也就是它无法知道两次登录服务器的客户端是不是同一个客户端。造成的后果就是每次我们如果要登录一个需要账号密码的网站，每次登录都要输入账号密码，显然这是用户的噩梦。而且我们现在登录网站也没有这个问题。

`Cookie Session`的出现解决了这个问题。这个流程主要是这样

- 用户访问一个需要登录的网站，用户输入账号密码发送到服务器。
- 服务器这边收到账号密码，生成一个`SessionId`存在服务端，然后响应请求，并且在响应头中添加一个`Set-Cookie`选项，里面有一些`Cookie`的信息。
- 客户端接受到响应，根据`Set-Cookie`的信息保存一个本地`Cookie`。下次登录这个网站就会把`Cookie`随着请求一起发送。
- 服务端根据`Session`和`Cookie`信息验证用户身份是否有效，有效则用户可以直接访问对应资源。

这样的实现方式简单地解决了`HTTP`协议的无状态问题，但是也出现了新的问题。

- 服务器存储压力。每登录一个用户就要生成存储一个`SessionId`，而且如果是服务器集群，还需要将`SessionId`同步到每一台服务器。
- `CSRF`攻击会盗用`Cookie`，不安全。

## Token

为了解决`Cookie Session`登录的问题而产生的登录方式。`Token`是由服务端生成的一个字符串，每次客户端请求带上这个字符串就能实现登录。基本使用方法和`Cookie`基本一致，只是服务端这边验证`Token`的有效性的时候并不用额外存储任何东西。

基于`JWT`算法实现的`Token`能够实现比较安全方便的登录，流程图如下

![img](https://cdn.nlark.com/yuque/0/2022/png/32666946/1668695224361-319d48b5-ea22-462b-935b-c3e9c8ad9a0e.png)

- `header`。声明`Token`所使用的签名算法。
- `payload`。表明`Token`的目的以及生成的时间，这个时候是为了回收权限而做的。
- `signature`。使用签名算法和`header payload`的`base64`编码生成的字符串，能够防止`Token`被人为修改。

## SSO单点登录

认证中心的登录方式。比如一家大型企业内部有很多站点，这时候一个站点一个登录明显不方便，所以采用`SSO`的单点登录方式。实现一次登录，处处可访问。基本流程：

- 用户登录其中一个需要权限的站点，站点将请求重定向至一个认证中心。
- 认证中心提示用户登录，验证用户的信息有效并且保存用户的登录信息（`Cookie`写入）。然后将请求从定向至用户本想访问的网站，并且带上一个`ticket`授权码。
- 原网站接受到请求，将向认证中心验证`ticket`的有效性，有效就运行请求。

这之后如果用户访问一个没有登录但是被统一个认证中心管理的网站，就会重复上述步骤。只是这一次认证中心已经有了我们登录的信息，所以直接发放`ticket`我们就可以访问这个新的网站了。

## OAuth第三方登录

这个就是我们经常在各种网站里面看见的微信登录、QQ登录方式。

![img](https://cdn.nlark.com/yuque/0/2022/webp/32666946/1668696075426-c21b5c0d-9581-4451-b901-3d1f54806c3a.webp)

和认证中心基本类似，只是借助于第三方认证的方式小型的公司就能比较方便的搭建起登录的流程。这种方式开箱即用非常方便，对于用户和开发者都比较友好

只是在选择第三方平台的时候需要仔细斟酌。	