> 手麻了。

### TCP三次握手

最开始服务端和客户端均处于`closed`状态，然后服务端主动开启`LISTEN`准备接收报文。

**第一次握手**。

客户端将`TCP`首部中的`SYN`置为1，并且初始化一个随机序列号`client_isn`。随后将这个`SYN`报文（包含随机序列号）发送给服务端，然后进入`SYN-SENT`状态。这次握手告知服务端，客户端想要建立`TCP`连接。

**第二次握手**。

服务端接收到客户端发送的`SYN`报文后，将`TCP`首部中的`ACK`置为1，同时将其中的确认应答号变为`cilent_isn+1`，生成`ACK`报文。然后初始化一个自己的随机序列号`server_isn`，并生成`SYN`报文。服务端同时将`ACK SYN`两个报文一并发送给客户端，然后进入`SYN-REVD`状态。此次握手是告诉客户端服务端知晓了需要建立`TCP`连接，请根据返回的信息进行应答正式建立连接。

**第三次握手**。

客户端接受到服务端发送的两个报文，通过`ACK`报文确认确实是自己想要建立连接的那台服务器。然后根据`server_isn`生成确认应答号以及`ACK`报文，并且将`ACK`报文发送给服务端，然后进入`ESTABLISHED`状态。服务端接受到`ACK`报文后就进入`ESTABLISHED`状态。双方都进入这个状态后`TCP`连接正式建立完毕，可以开始发送`HTTP`请求了。此次握手告诉服务器客户端已经就绪，可以进行正式的连接建立。

#### 灵魂拷问：为啥要三次握手，两次不行吗？

两次握手一般就是放弃最后一个握手，带来的最大的问题就是建立历史连接。比如客户端发送第一次`SYN`报文后就宕机了，正好这个发送的报文又遇到了网络堵塞，然后我重启客户端又发送一次`SYN`报文。服务端这边旧报文比新报文先抵达了，在两次握手的情况下，服务端每接收一个`SYN`报文就要建立一个连接，新旧报文明明是要建立相同的链接，但是却各自建立了相同的连接，造成了资源的浪费。

三次握手就能避免这个问题。还是上面的问题，建设两次`SYN`报文的`cilent_isn`分别是90和100，客户端发送第二次报文后，期望得到的确认号是101，但是实际会得到91，此时客户端发现确认号有问题就会发送`RST`告诉服务端，这个90序列号的连接需要释放，不要建立它的连接。

### TCP四次挥手

开始时双方均处于`ESTABLISHED`状态，两边都可以发起断开连接的请求。下面以客户端为例介绍。

**第一次挥手**。

客户端发送`FIN`报文到服务端，然后进入`FIN_WAIT_1`状态。服务端接受到`FIN`报文之后进入`close_WAIT`状态。此次挥手告诉服务端，客户端想要断开连接。

**第二次挥手**。

服务器接收到`FIN`报文，生成一个`ACK`报文发送给客户端。客户端进入`FIN_WAIT2`状态。此次挥手告诉客户端，服务端已经明白了想要断开连接的请求。但是服务端可能还要处理一些数据，或者发送一些数据给客户端，暂时还不要断开连接。

**第三次挥手**。

服务器在上一步中处理完数据后，发送一个`FIN`报文，进入`LAST_ACK`状态。此次挥手告诉客户端数据处理完毕，可以正式断开连接了。

**第四次挥手**。

客户端接受到服务器的`FIN`报文，明白可以正式断开连接。客户端发送`ACK`报文，然后进入`TIME_WAIT`状态，之后会自动关闭。服务端接受到这个`ACK`报文之后就知道客户端那边已经确认可以关闭了，于是直接关闭连接。

#### 灵魂拷问2.0：能不能只有三次挥手？

也不是不行，三次挥手就是将第二次和三次的`ACK FIN`一起发送。此时表示，客户端申请断开连接的时候，服务端这边已经没有需要处理和发送的数据了，所以这两个报文就可以一起发送了。