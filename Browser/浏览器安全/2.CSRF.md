## CSRF跨站请求伪造

`CSRF`是一种挟持用户在已经登录的`web`上进行出于非用户本意操作的一种攻击方式。`CSRF`利用了网站对于浏览器的信任，以及浏览器自身的同源策略来实现的。

`CSRF`的攻击步骤如下：

- 用户登录了网站`A`，并且浏览器保存了`cookie`信息。
- 用户未退出网站`A`，使用同一个浏览器打开网站`B`。
- 网站`B`含有恶意代码，它向网站`A`发送了一个访问请求。
- 浏览器发现要发起请求（这个请求是网站`B`伪造的，用户并没有想要在此处访问`A`网站），并且请求的网站是已经登录的网站`A`，于是就会将`cookie`携带到请求中发送，由此网站`B`就实现了使用用户的权限对于网站`A`进行操作。

### 类型

- `GET`，构造一个`<img>`标签，里面添加一个请求就能实现。
- `POST`，构建一个表单并且隐藏，用户点击进页面就自动发送表单。
- 恶意链接，在`<a>`标签的`href`属性中添加链接。

### 防御

#### 验证码。

敏感类操作设置验证码，强迫用户和页面直接交互。

#### Cookie的SameSite属性

- `Strict`：禁止第三方`cookie`，如果你是从另一个站点去登录原站点的话，该模式会直接禁止发送`cookie`，必须是在同一个站点下的请求才会携带`cookie`。
- `Lax`：第三方站点可以通过`GET`的方式发送请求携带`cookie`，但是发送`POST`请求，在标签中嵌入请求等方式不会发送`cookie`。

### http头部的referer/origin字段

该字段标识了`http`请求的来源，服务器就可以根据这个字段中的内容判断是否有`CSRF`的风险，并决定是否要响应这个请求。

### CSRF token

服务器第一次响应浏览器的请求的时候，在返回资源页面中嵌入了一个`CSRF token`,下一次浏览器要登录网站进行操作的时候就必须携带上这个`CSRF token`，服务器会验证它是否合法。此时如果发生`CSRF`，那么发送的请求中也没有正确的`CSRF token`，服务器也就不会响应从而实现防御。