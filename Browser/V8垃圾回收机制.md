## JavaScript的垃圾回收

JavaScript中并没有像`C/C++`一样的手动进行内存释放的能力，所以垃圾回收是需要`js`引擎来执行的。我们一般听说的`js`的垃圾回收策略有标记清除法和引用计数法。

引用计数法：顾名思义，就是查看对象的引用数量。如果为0则说明应该被回收，但是如果两个对象互相引用的话就会出现内存泄漏，无法回收，比如这个例子：

```javascript
let obj1 = {name: 'Jack'}
let obj2 = {name: 'Tom'}
obj1.a = obj2
obj2.a = obj1
```

标记清除法：标记对象的`可达`性。可达性是指从根节点（比如window对象）出发，能够到达的所有子节点。最终没有被标记的节点为不可达，进行回收。

这样说垃圾回收当然没错，但是还不够全面。

## V8引擎的垃圾回收

`js`中有两种数据类型，分别存放在栈空间和堆空间中。由于栈空间中存储的数据比较固定，拓展性低，所以由系统自动回收，堆空间中的数据可扩展性强，需要V8引擎使用垃圾回收（GC）算法来进行回收

### 代际假说

V8引擎针对堆空间中的对象，将其分类为新生代和老生代，并且采用不同的回收算法和垃圾回收器进行处理。

- 新生代的对象存活事件短且数据量小，使用副垃圾回收器和`Scanvenge`算法回收。`Scavenge`算法将新生代分为`from-space`和`to-space`空间，对象最开始被写入`from-sapce`空间，然后采用标记清除后，存活下来的对象被**复制整理**到`to-space`中。最后反转`to-space`和`from-space`，开启下一轮的循环。
- 老生代中的对象一般是体积大，存活时间长的对象。**新生代中经理两次垃圾回收还未被清除的对象，会晋升到老生代。**所以不适合再采用`Scavenge`这种空间换时间的算法。而是采用`Mark-Sweep`和`Mark-Compact`算法，也就是标记清除和标记整理算法，标记整理在标记清除的基础上发展而来，避免产生大量的内存碎片。

### 全停顿 `Stop-The-World`

砸瓦鲁多！因为垃圾回收也是需要`js`引擎来实现的，所以进行垃圾回收的时候就会暂停`js`代码的执行，如果垃圾回收时间太长就会造成页面卡顿。

### 增量标记和惰性清除

增量标记就是让`js`引擎在执行`js`代码的空隙执行垃圾对象的标记工作，惰性清理则是让`js`引擎优先执行代码，延迟进行垃圾回收或者只清理出能够供`js`代码运行的空间。

### 并发和并行

并发就是启动一个辅助线程来进行垃圾回收工作，这样就不妨碍主线程继续执行代码，主线程几乎不用参与垃圾回收。并行也是启动辅助线程，但是主线程需要参与垃圾回收，此时花费的时间是单线程清除的总时间除以目前的线程数量并加上一些线程同步花费的时间。

目前V8引擎对新生代采用了并行机制，对老生代采用并发机制。

**增量标记、惰性回收、并发并行都是优化垃圾回收的方式。（Orinoco优化）**